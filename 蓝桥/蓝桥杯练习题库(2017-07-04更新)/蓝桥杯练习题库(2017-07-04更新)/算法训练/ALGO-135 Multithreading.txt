算法训练 Multithreading
时间限制：1.0s   内存限制：256.0MB
问题描述　　现有如下一个算法：
　　repeat ni times
　　yi := y
　　y  := yi+1
　　end repeat
　　令n[1]为你需要算加法的第一个数字，n[2]为第二个，...n[N]为第N个数字（N为需要算加法的数字个数），
　　并令y初始值为0，先令i=1运行这个算法（如上所示，重复n[i]次），然后令i=2运行这个算法。。直到i=N。注意y值一直不要清零。最后y的值就是你需要的加法答案。
　　你想知道，有没有某种运算顺序能使答案等于W。
　　一个循环中的全部语句，是不能改变在总的语句排列中的相对顺序的。
　　（这里的第i个循环是指这n[i]*2条语句。就是你把属于第i个循环的语句抽出来看，它们需要按照原顺序排列。在你没有运行完这个循环的最靠前一条未完成的 语句的时候，你是不能跳过它先去完成这个循环后面的语句的。你能做的仅是把若干个循环按照你所规定的顺序“归并”起来。）
　　举个例子，n[1]= 2 ,n[2]=1, W=1.一种可行的运算顺序是“2 1 1 1 1 2”，数字为几表示运行第几个算法的下一条语句（你可以看到”1”出现了4次，是因为n[1]=2即循环两次，而每次循环里面有两条语句，所以2*2=4次）
y值
y[1] 值
y[2] 值
执行0条语句过后
0
0
0
执行1条过后(y[2]=y)
0
0
0
执行2条过后(y[1]=y)
0
0
0
执行3条过后(y=y[1]+1)
1
0
0
执行4条过后(y[1]=y)
1
1
0
执行5条过后(y=y[1]+1)
2
1
0
执行6条过后(y=y[2]+1)
1
1
0
 　　可以看到，最后y值变成了1，也就完成了我们的任务。输入格式　　第一行你会得到用空格分开的两个整数N(1&lt;=N&lt;=100)和W(-10^9&lt;=W&lt;=10^9)，（N为需要算加法的数字个数，W是你希望算出的数）。
　　第二行你会得到n个整数n[i] (1&lt;=n[i]&lt;=1000).输出格式　　第一行您应该输出Yes(若能以某种顺序使得这个算法得出W的值) 或No。
　　如果第一行是No，接下来就不用继续输出了。
　　如果是Yes, 请在第2行输出2*sigma(n[i])个用空格隔开的数，表示任意一种满足条件的运算顺序。样例输入1 10
11样例输出No样例输入2 3
4 4样例输出Yes
1 1 2 1 2 2 2 2 2 1 2 1 1 1 1 2样例输入3 6
1 2 3样例输出Yes
1 1 2 2 2 2 3 3 3 3 3 3数据规模和约定　　对于30%的数据，n&lt;=4, n[i]的和小于10.
　　对于100%的数据，n&lt;=100 , -10^9&lt;=W&lt;=10^9, 1&lt;=n[i]&lt;=1000

